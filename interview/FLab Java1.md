```
F-lab JAVA Interview

#1편(https://f-lab.kr/blog/java-backend-interview-1)


# 자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다. 이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?
>>  
equals() 는 데이터의 동등성 비교를 위해 사용합니다. 
Object 의 equals() 는 기본적으로 == 연산자를 사용하여 동일성비교를 하도록 동작합니다. 
동등성 비교를 하기위해서는 메서드를 오버라이딩하여 동등성을 비교하도록 재정의해야합니다.
예를들어, String 클래스도 오버라이딩하여 글자가 같으면 true 를 반환하도록 구현된것을 확인할수있습니다.

hashCode() 는 실제 메모리의 주소가 아닌 JVM 이 객체를 식별할 수 있게 생성한 정수값을 반환합니다.
해시 버켓의 자리를 결정하는데 사용됩니다.(결정하는데에는 모듈러 연산도 수행함)

	
	## "hashCode" 를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있습니다. 어떤 케이스일 때 그럴 수 있을까요? 
	>> 
	해시코드 메서드 내부 구현이  잘못 설계되었을 경우 성능이 떨어집니다.
	예를들어 어떤 입력값이든 100 을 반환하는 해시코드라면 
	모든 데이터가 동일한 버켓에 저장되어 항상 해시충돌이 발생하여 성능이 떨어지게됩니다.


	## "HashMap"은 내부적으로 어떻게 구현되어있길래 그렇게 빨리 값을 탐색할 수 있을까요?
	>>
	해시맵은 키를 값에 매핑하는 추상자료형인 연관배열을을 구현한 자료구조입니다.
	트리와 비교하자면, 트리는 다른 값과의 비교를 통해 저장된 위치를 찾아내지만
	해시는 해시함수를 통해 스스로와만 비교하여 저장된 위치를 찾아내므로 O(1) 시간복잡도로 빠르게 데이터를 찾습니다.

	하지만 해시함수는 임의의 크기를 더 작은 고정크기의 데이터로 변환하기때문에 
	키가 다른 데이터여도 같은 버켓에 저장될 가능성이 존재합니다. 이런 경우를 해시충돌이라고 말합니다.

	자바에서는 해시충돌이 발생할 경우 링크드리스트를 이용하여 체이닝 방식으로 값을 저장합니다.
	현재 리스트의 값이 아니라면 다음 리스트로 이동하는 방식으로 값을 찾습니다.

	동일 버켓에 저장된 값이 커질 경우 매번 O(N) 의 탐색이 발생합니다.
	이를 방지하기위해, 자바에서는 하나의 해시버켓 크기가 8을 넘어가면 링크드리스트 대신 O(logN/M) 의 시간복잡도를 가지는 레드블랙트리로 자료구로를 변경합니다.

	파이썬의 경우 링크드리스트를 통해 새로운 메모리를 할당하는 과정에 대한 오버헤드를 피하기위헤
	오픈어드레싱 방식을 사용한다고합니다. 
	참고로 오픈어드레싱은 로드팩터가 80정도를 넘지 않는 선에서는 체이닝 방식보다 더 빠르다고합니다.


	## 기존 "HashMap" 의 시간복잡도는 얼마이고, "hashCode" 를 잘못 오버라이딩 했을때의 시간복잡도는 얼마일까요?
	>> O(1) 과 O(N) 입니다.


	### equals and hashcode 해시 자료구조에서 동작 과정
	>>	
	해시코드를 통해 같은 정수값을 가지는 지 확인합니다
	그 후 비교적 연산이 더 무거운 연산인 equals()를 통해 동등성을 비교합니다.
	트루를 반환하면 동등객체로 판별합니다.

	그러므로 내가 작성한 클래스를 해시 컬렉션에서 사용하고 싶다면, 둘다 재정의해야합니다. 



# StringBuilder와 StringBuffer의 차이는 무엇일까요?
>>
스트링버퍼는 멀티스레드환경에서 스레드세이프하다는 차이점이 있습니다.
이는 스트링버퍼는 내부적으로 synchronized 키워드를 통해 상호배제를 보장하기 때문입니다.
	
	## 왜 동기화(synchronized)가 걸려있으면 느린걸까요?
	>>
	멀티스레드 환경에서 스레드가 블락되고 다시 깨어나는 과정이 존재하기 때문입니다.
	synchronized 블록에 진입하기 위해서는 스레드는 모니터락을 획득해야합니다.
	하지만 이미 락이 점유중이라면, 스레드는 CPU 의 제어권을 포기하고 블락 상태가 됩니다.
	이후 락이 해제될 경우 notify 되어 꺠어나게 되며, 다시 스케줄러의 선택을 받기까지 대기합니다.
	결과적으로 대기시간이 발생하며 이 과정에서 컨텍스트스위칭도 발생하여 성능 저하가 발생합니다.

	## 싱글 스레드로 접근한다는 가정하에선 "StringBuilder" 와 "StringBuffer" 의 성능이 똑같을까요?
	빌더가더 빠릅니다.
	버퍼에서는 락을 획득하고 반납하는 과정이 존재하며, synchronized 블락안에서 사용하는 변수들은
	자동적으로 volatile 이 적용됩니다. 이는 항상 메모리의 값을 접근하기때문에 캐시의 이점을 살리지 못해
	성능이 더 좋지 않을 것 같습니다. 



# System.out.println 메소드는 현업에서 절대 쓰지 말라고하는 메소드인데요. 그 이유가 무엇일까요?
>>
프린트는 Blocking IO 방식으로 동작합니다. 블락킹 아이오가 발생하면 해당 스레드는 데이터를 읽을때까지 블락됩니다.
또한 synchronized 로 동작하기 때문에 락을 획득하지 못하는 경우에도 블락이 발생합니다.

결과적으로 스레드가 블락되므로 프로그램의 효율성이 저하됩니다.
또한 이 과정에서 컨텍스트 스위칭이 빈번하게 발생하므로 CPU 의 유휴시간이 증가하게됩니다.
	
	
	## Blocking IO 는 왜 느려?
	>> 
	시스템 콜이 발생하는동안 스레드는 블락되기 때문이다.


# ArrayList 는 내부적으로 어떻게 구현되어있을까요?
>>
원소를 저장하는 배열과, 배열의 크기를 나타내는 size 변수를 가지고 있습니다.

	## 배열로 구현되어있다면 분명 크기가 꽉 차면 일반 배열처럼 예외가 발생할텐데 ArrayList 는 어떻게 무한히 데이터를 받을 수 있을까요?
	>>
	ArrayList 는 동적배열 자료구조이기 때문입니다. 할당된 크기를 모두 사용하면 기존 크기의 1.5배 크기가 더 큰 배열을 할당받는 더블링 과정이 발생합니다. 이 과정은 기존 값들을 모두 복사하여 새로운 배열에 저장한 후, 기존 배열은 GC에 대상이되는 방식으로 동작합니다. 


# 스레드는 왜 써야하는 것일까요?
작업을 처리하기 위해 사용합니다.
스레드를 늘리면 동시 처리량이 증가하여 어플리케이션이 성능이 좋아질 수도 있습니다.


동기/블라킹 방식으로 순차적으로 발생하는 어플리케이션이라면 오히려 성능 저하가 발생할 수 있습니다.


	## 스레드가 많으면 그러면 항상 좋을까요?

	관점1
	>> 순차적으로 동작해야하는 로직이라면 스레드가 많아도 실제로 사용하는 스레드는 한계가 존재
		(작업을 잘게 나눌 수 있다면 효율적)

	관점2
	>> 코어를 차지하기 위해 경합하는 스레드 수가 많아져 컨텍스트 스위칭이 빈번하게 발생하여
	   어플리케이션의 성능이 저하될 수 있다. 또한 스레드는 메모리를 크게 차지하므 메모리 공간이 부족해질 수 있다.	 

	   메모리의 크기 >> 스레드는 32비트 컴퓨터에서는 1mb, 64비트에서는 4mb 의 공간을 사용합니다.

	관점3
	>> 
	   CPU 바운드라면 스레드와 코어 수를 비슷하게 설정하여 컨텍스트 스위칭 횟수를 최소화하 것이 좋다.
	   제가 사용하는 스프링의 톰캣의 경우 IO 바운드 프로세스이므로
	   멀티 스레드를 최대한 활용하여 CPU 가 유휴시간을 최소한으로 가지도록 스레드를 설정할것이다.




# Blocking IO와 Non-Blocking IO 의 차이를 말씀해주세요.
>>
블라킹은 호출된 함수가 제어권을 가지고
논블라킹은 호출된 함수가 제어권을 바로 반납합니다.

블라킹아이오에서는 입출력동작동안 스레드는 멈추게 되고 작업을 수행할 수 없게됩니다.
블라킹아이오에서는 CPU 의 유휴시간을 제거하기위해 스레드 수를 늘리는게 좋습니다.

논블라킹에 스레드는 다른 작업을 계속하여 수행할 수 있습니다.



	
	## CPU가 쉬는 것을 막으려면 어떻게 해야할까요?
	>> 스레드 수를 증가시킵니다.

	## Non-Blocking IO는 CPU 활용률이 어떨까요?
	>> 좋습니다.












```
