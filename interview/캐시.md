
## LRU 캐시 ##
```
>> 캐시 공간이 가득찼을 때, 가장 오랬동안 접근하지 않은 데이터를 제거하는 알고리즘입니다.

	어떤 자료구조로 구현할 수 있나요?
	>> 위해 더블링크드리스트 사용하고 
	   해시맵을 사용합니다.

		리스트 대신 배열을 사용하면 어떨까요?
		>> 캐시의 접근 순서를 관리하기 위한 자료구조로 배열을 사용한다면
			접근 순서가 바뀔때마다 쉬프트 연산이 발생하여 매번 O(N) 의 연산이 수행되므로 비효율적이됩니다.


	해시맵을 쓰는 이유가 뭔가요?
	>> O(1) 복잡도로 원하는 노드에 접근하기 위합입니다.
	   해시맵의 각 엔트리는 밸류에 노드 주소를 저장함으로써 O(1) 복잡도로 원하는 노드에 접근할 수 있게 됩니다.

	왜 더블링크드리스트를 쓰나요?
	>> head 와 tail 포인터를 통해 노드를 추가하고 삭제하는 과정 둘다 O(1) 로 접근하기 위함입니다.

	카페인캐시
	>> 
		- LRU, LFU 알고리즘의 장점을 섞은 tinyLFU 라는 알고리즘 사용
			- LFU 알고리즘으로 인해 자주 사용되는 데이터는 protected 영역에서 보관되어, 
			  LRU 에 의해 제거되지 않는 방식

		- 벤치마크 성능 우수

	- https://www.youtube.com/watch?v=HpuIrGiHwTo
	- https://medium.com/naverfinancial/니들이-caffeine-맛을-알아-f02f868a6192



LRU 캐시

# 설명
- 키를 가지고 밸류를 찾는 캐시 자료구조
- 저장 공간이 모두 찬다면 LRU 알고리즘을 사용하여 가장 과거에 사용된 데이터를 제거하는 방식
- 조건
  - GET: O(1)
  - PUT: O(1)


#구현 자료구조

1. 해시맵
해시맵을 사용하여 키밸류 형태로 저장하면 조회와 삽입을 O(1)에 해결할 수 있어보인다.
하지만 저장공간이 다 차서, evicit가 발생할 떄, 가장 오래전에 접근된 데이터를 확인할 수 없다. 

어떻게 해야 최근에 사용된 순서로 데이터를 정렬할 수 있을까?
-> 배열/링크드리스트/더블링크드리스트를 사용하여 위치를 확인


2. 배열
past      recent
[1, 2, 3, 4] // 새로운 데이터 5를 넣는다.
[2, 3, 4, 5]
삽입 시에 쉬프트 연산이 발생하여 O(1)을 만족할 수 없다.


3. 링크드리스트

        past          recent
head -> 1 -> 2 -> 3 -> 4 

past와 recent가 양 극단에 접근하기위한 시간 차이가 발생한다.
삭제와 추가 모두 O(1)에 발생해야하므로 사용할 수 없다.


*순환은 안될까?
순환 링크드 리스트에서 노드를 삭제하는 경우, 노드의 앞과 뒤에 위치한 노드를 찾는 작업이 필요합니다. 이를 위해선 해당 노드로부터 시작하여 순환 링크드 리스트를 전체 탐색해야 하는데, 이는 시간 복잡도 측면에서 비효율적일 수 있습니다.


4. 더블링크드리스트

해시맵의 밸류는 링크드리스트의 주소를 가진다.
eviction 이 발생하여 가장 오래된 링크드리스트를 제거해야한다.
이 링크드리스트를 해시맵에서도 제거해야하기때문에
링크드리스트는 키와 밸류 둘다 가지고있어야한다.
```




읽으면 좋은 자료
- https://www.youtube.com/watch?v=HpuIrGiHwTo
- https://www.baeldung.com/java-lru-cache
- https://velog.io/@ghkvud2/LinkedHashMap으로-LRU-구현하기
