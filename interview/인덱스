인덱스

랜덤IO vs 순차IO
>> 순차는 페이지를 디스크에 기록하기 위해 1번만 시스템 콜 호출 랜덤은 페이지가 3개라면 디스크의 헤드를 3번 움직이므로 시스템 콜 3번 호출


인덱스
>> 인덱스란 데이터베이스에서 쓰기 성능을 희생하고 읽기 속도를 향상시키기 위해 사용하는 기술입니다. 

	동작원리
	>> 
	인덱스는 컬럼값과 레코드의 주소를 키 밸류 쌍의 데이터로 저장하며, 데이터들은 컬럼값을 기준으로 정렬된 상태로 관리됩니다.

	인덱스가 빠른 조회를 할 수 있는 이유는 정렬된 상태에서 값을 빠르게 찾는 이진탐색 개념이 사용되기 때문입니다.
	이진탐색처럼 O(logn) 의 시간복잡도를 가지지만, 비트리의 경우 키를 2개 이상 가질 수 있기때문에 키가 1개인 이진탐색보다는 더 빠르게 범위를 좁혀 값을 찾을 수 있습니다. 범위를 빠르게 찾는다는 것은 디스크를 읽는 횟수가 적어짐을 의미하며, 이는 빠르게 값을 찾을 수 있는 이유라고 생각합니다.



	인덱스 자료구조? 
	>> 
		비트리를 사용하며, MySQL 의 경우 비트리의 변형인 비+트리를 사용합니다.
		비트리는 밸런스드 트리의 약자로, 여러개의 자식노드를 가질 수 있는 자료구조입니다.
		하나의 노드는 정렬된 상태의 키값들을 가집니다. 값을 찾을 때, 이 키값들과 대소관계를 비교하여 탐색 범위에 맞는 자식 노드로 이동하는 방식으로 동작합니다.
		
		>> 비+트리 차이점?
		브랜치노드: <컬럼, 리프노드 포인터>
		리프노드: <컬럼, 프라이머리 키> 
		- 리프노드끼리 링크드 리스트로 연결되어 있으므로 범위 검색에 특화되어 있다.
		- 항상 리프노드까지 탐색하므로 균일한 성능을 보장한다. 


	인덱스 어떤 기준으로 설정해?
	>>
		- 조건절에 자주 사용되거나, 조인문에 사용되는 컬럼
		
		- 멀티 컬럼 인덱스에서는 = 연산은 앞으로, 범위 검색을 뒤에 둬서 스토리지 엔진에서 읽어들이는
		  데이터의 범위를 감소시킨다.

		- ORDER BY 의 경우 인덱스를 통해 정렬 연산을 피할 수 있으므로 인덱스 설정
		
		- 인덱스 만으로 처리할 수 있도록 커버링 인덱스 (MySQL 클러스터링 인덱스 장점)

	모든 컬럼에 인덱스를 걸면 좋나?
	>> 
		쓰기 작업마다 설정한 인덱스들에 대해 쓰기 작업이 추가적으로 발생하므로, 좋지 않습니다.
		새로운 레코드를 추가할때마다 드는 비용이 1이라면, 인덱스는 1.5정도의 비용이 든다고 한다.
		만약 인덱스를 3개 사용한다면 하나의 레코드 삽입마다 (1 + 4.5 = 5.5)의 비용이 듭니다.

		그러므로 자주 사용되는 조건문이나 조인문처럼 필요한 컬럼에만 설정하는 것이 좋습니다.

	인덱스가 비효율 적인 경우는?
	>> 
		대량의 데이터를 읽는 경우, 전체 데이터 25%정도를 넘으면 인덱스 없이 풀 테이블 스캔
		리프노드에 적힌 레코드 주소를 읽는데, 매 레코드를 읽을때마다 랜덤 액세스하므로 느린 것.


	선택도: 조건문에 컬럼을 사용했을때 조회되는 데이터의 비율, 예를들어 100건중 10개가 조회되면 선택도는 10%
	카디널리티: 주민, 이름, 성별 순으로 카디널리티가 낮아짐
	선택도가 낮고 카디널리티가 높은 컬럼을 인덱스로 설정해야 인덱스가 효율적



	클러스트링 인덱스?
	>> PK 값에 대해 기본적으로 생성되는 인덱스입니다. PK값에 따라 물리적인 저장 공간이 결정되는 특징을 가지기 때문에
	PK 값을 통해 범위 검색을 사용하면 순차적으로 IO 를 하기때문에 매우 빠릅니다.	
	InnoDB 는 세컨더리가 항상 PK 값을 가지기때문에 커버링 인덱스 태우기 좋다.


조인문
>>
양 쪽 컬럼 모두 인덱스가 잘 설정됐음 -> 중첩 루프 조인 사용, 드라이빙 테이블이 모수 적은 쪽으로 
인덱스 조건 미흡 -> 블록 네스티드 루프 조인 혹은 해시 조인, 최근에는 해시 조인만 사용됨
				조인 버퍼를 사용 
