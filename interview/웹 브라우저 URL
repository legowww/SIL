웹브라우저에서 URL을 입력하면 어떤 일이 생기나요?
>>
1. /etc/hosts 파일을 확인합니다. 
   이 파일에는 예를들어, localhost 는 127.0.0.1 이런식으로 정적으로 설정한 정보가 적혀있습니다. 


2. 그 다음에는 웹 브라우저의 DNS 캐시를 확인합니다. 캐시에 도메인이 존재하지 않는다면
   로컬 DNS 서버에 질의를 해야하는데요, DNS 서버의 주소는 DHCP ACK 응답을 통해 /etc/resolve.conf 파일에 기록된 상태입니다. 운영체제는 이 파일을 읽어 53번 포트가 적힌 UDP세그먼트를 생성하여 로컬 DNS 서버에 질의를 요청하게됩니다.


3. 로컬 DNS는 루트 DNS서버, TLD DNS 서버, 책임 DNS 서버에 반복적으로 질의하면서 책임 DNS 서버에서 실제 	
	도메인의 주소를 가진 type A 레코드를 획득하여 클라이언트에게 반환합니다. 참고로 질의 과정에서 DNS의 캐싱 정보가 있다면 바로 반환합니다.


4. 이제 클라이언트와 서버와의 TCP 3way handshake 를 수행합니다. 만약 서버가 HTTPS 프로토콜을 사용한다면 
   핸드셰이크 이후 SSL 핸드셰이크라는 추가 과정을 수행합니다.  


5. 연결이 끝난 후에는 HTTP GET 요청을 서버로 전송됩니다. 


6. 서버는 요청에 대한 HTTP 응답 메세지를 클라이언트로 전송합니다. 클라이언트의 웹 브라우저 프로그램은 메세지 바디를 
   읽어 HTML 을 추출한 후 화면을 구성합니다.

-https://aws.amazon.com/ko/blogs/korea/what-happens-when-you-type-a-url-into-your-browser/


3way handshakes?
>>
1. 클라이언트는 SYN 플래그를 1로 설정한 SYN 세그먼트를 서버에 전송합니다.

2. 서버는 SYN 세그먼트를 수신하고 통신에 사용될 송수신 버퍼를 할당합니다. 그 후 SYN, ACK 플래그가 1로 
   설정되어있는 SYNACK 세그먼트를 전송합니다.

3. 클라이언트는 SYN ACK 세그먼트를 수신하고 송수신 버퍼를 할당합니다. 그리고 ACK 세그먼트를 서버에 전송합니다.
   이때부터 TCP 상태는 ESTABLISHED 상태가 되므로 서로 페이로드를 주고받을 수 있게됩니다.

결과:
- 리시브 윈도우의 크기를 설정함
- 초기순서번호를 통해 송수신 버퍼를 초기화


SSL?
>>
HTTP 메세지를 암호화하기 위해 사용하는 애플리케이션 계층에서 사용하는 라이브러리입니다.
기본적으로 HTTP 는 암호화 되지 않은 평문을 전송하기때문에 보안에 취약합니다. 이를 해결하기위해
SSL 을 사용하면 HTTP 를 암호화하여 TCP 소켓 밖으로 내보낼 수 있습니다.
SSL 이 적용된 HTTP 를 HTTPS 라고 부릅니다.

   TLS?
   >> SSL 의 최신버전이라고 알고있다.

   SSL handshkaes?
   >>
   1. 3way handshakes 가 끝난 이후 수행합니다.

   2. 클라이언트는 서버에 SSL Hello 메세지를 보냅니다. 이 단계에서는 클라이언트는 서버에게
      자신이 사용할 수 있는 대칭키, 공개키, MAC 키, MAC 알고리즘에 대해 알려줍니다.

   3. 서버는 통신에 사용할 암호화 알고리즘과 인증서를 클라이언트에게 전송합니다.

   4. 인증서는 CA의 개인키로 암호화되어있는데, 웹 브라우저는 기본적으로 여러 CA 들의 공개키를 가지고있기때문에
      인증서를 복호화할 수 있습니다. 복호화하면 서버의 공개키를 획득할 수 있습니다.
      클라이언트는 서버의 공개키로 Pre Master Secret 을 암호화하여 서버에 전송합니다.

   5. 서버는 자신의 개인키로 패킷을 복호화하여 PMS 를 획득합니다.
      클라이언트와 서버는 PMS 를 통해 MS 를 생성하고, MS 를 통해 대칭키를 생성합니다.
      클라이언트과 서버는 이제부터 대칭키를 통해 암호화된 메세지를 주고받고, MAC 을 통해 메세지 무결성을 보장받을 수 있습니다.


   즉, 공개키로 대칭키를 만들기위한 정보를 전달하고, 대칭키를 통해 암호화된 통신을 수행합니다.
   이는 대칭키의 연산이 공개키에 비해 훨씬 가볍기때문입니다.   


4way handshakes?
>>

1. 클라이언트가 FIN 플래그가 1인 세그먼트를 전송합니다.
2. 서버는 ACK 응답을 전송합니다. 
3. 클라이언트는 ACK 을 수신받고, 버퍼가 해제됩니다.
3. 서버는 모든 데이터를 보낸후 FIN 세그먼트를 전송합니다.
4. 클라이언트는 FIN 을 수신받은 후 TIME_WAIT 상태가 되며, ACK 응답을 전송합니다.

   >> TIME_WAIT 는 왜 존재하는가?
   - 1. 지연 패킷이 존재할 가능성이 남아있기 때문
   - 2. 클라이언트가 마지막에 전송한 ACK 응답이 유실될 경우 소켓이 해제되지 못해 서버의 메모리 낭비가 발생할 수
        있습니다. 서버는 연결을 해제하기위해 다시 FIN 을 보내는데, TIME_WAIT 를 통해 소켓이 해제되지 않고
        유지되므로 FIN 세그먼트를 받고 다시 ACK 을 응답할 수 있습니다.
