## 트랜잭션
> 트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가
100% 적용되거나(COMMIT을 실행했을 때) 아무것도 적용되지 않아야(ROLLBACK) 함을 보장한다. 완벽하게 처리하지 못했다면 
원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.

1. 트랜잭션은 작업의 완전성을 보장해 주는 것이다. 
2. 트랜잭션은 데이터의 정합성(데이터의 값들이 일치함)을 보장하기 위한 기능이다.
3. InnoDB 는 트랜잭션이 지원되지만 MyISAM 이나 MEMORY 엔진은 트랜잭션이 지원되지 않는다.
4. 격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨을 말한다.

### 주의사항
```
트랜잭션 또한 DBMS 의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.

- DBMS 의 커넥션은 개수가 제한적이어서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 여유 커넥션의 개수는 줄어들 것이다. 그리고 어느 순간에는 
각 단위 프로그램에서 커넥션을 가져가기 위해 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있다.

- 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게든 DBMS 의 트랜잭션에서 제거하는 것이 좋다.
프로그램이 실행되는 동안 메일 서버와 통신할 수 없는 상황이 발생한다면 웹 서버뿐 아니라 DBMS 서버까지 위험해질 수 있다.

- 사용자가 입력한 정보를 저장하는 작업은 하나의 트랜잭션으로 묶고, 단순 조회 작업은 트랜잭션에 포함할 필요는 없다.
```

---
## 잠금

1. 잠금은 동시성을 제어하기 위한 기능이다.
2. 잠금이 없다면 하나의 데이터를 여러 커넥션에서 동시에 변경할 수 있게되어, 해당 레코드의 값을 예측할 수 없다.
3. 잠금은 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.


### MySQL 엔진의 잠금
MySQL엔진은 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분으로 이해하면 되는데, MySQl 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만,
스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

`글로벌 락`: MySQl에서 제공하는 잠금 가운데 가장 범위가 크다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT 를 제외한 DML, DDL 들이 대기 상태로 남는다.

`테이블 락`: InnoDB 테이블의 경우 레코드 기반의 잠금을 제공하기 때문에, 대부분의 데이터 변경(DML) 쿼리에서는 테이블 락이 적용되지 않고, 스키마를 변경하는 쿼리(DDL)의
경우에만 영향을 미친다.

`메타데이터 락`: 테이블의 구조를 변경하는 경우에 획득하는 잠금이다.

### InnoDB 스토리지 엔진 잠금
InnoDB 스토리지 엔진은 MySQL 에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 채택하고 있다.
덕분에 InnoDBO 는 MyISAM 보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.

<img src="https://user-images.githubusercontent.com/70372188/216779822-aad6cb82-d15e-4bee-8f76-204feafa85ee.png" width="500" height="500"/>                                                                                                                                                                                                                                                                              


#### 레코드 락
```
레코드 자체만을 잠그는 것을 의미한다. InnoDB 스토리지 엔진은 레코드 자체가 아니라 `인덱스`의 레코드를 잠근다. 
인덱스가 없더라도 테이블 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

InnoDb에서는 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용하지만 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는
레코드 자체에서만 락을 건다.

변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸아야 한다.
```
![image](https://user-images.githubusercontent.com/70372188/216780329-f11c9f0e-13f1-4310-85bf-b6253ae87915.png)
```
// ix_firstname 이라는 인덱스가 준비돼 있다.
// employees 테이블에서 first_name='Georgi'인 사원은 253명이며
// first_name='Georgi' and last_name='Klassen'인 사원은 딱 1명만 존재한다.

// employees 테이블에서 first_name='Georgi' and last_name='Klassen'인 사원의 입사 날자를 오늘로 변경하는 쿼리를 실행해보자
mysql> UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' and last_name='Klassen';

UPDATE 문장이 실행되면 1건의 레코드가 업데이트될 것이다.
하지만 인덱스 조건은 firstname만 존재하고 lastname에 대해서는 존재하지 않기 때문에, first_name='Georgi'인 레코드 253건의 레코드가 모두 잠긴다.
```
#### 갭 락
```
레코드와 레코드의 사이를 잠궈서 중간에 새로운 레코드가 INSERT 되는것을 제어한다.
```
#### 넥스트 키 락
```
레코드 락과 갭 락을 합쳐놓은 형태의 잠금을 말한다. MySQl 서버에서는 `REPEATABLE READ` 격리 수준을 사용해야 한다.
```
#### 자동 증가 락
```
AUTO_INCREMENT 이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다.
InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 AUTO_INCREMENT락 이라고 하는 테이블 수준의 잠금을 사용한다.

AUTO_INCREMENT 락은 INSERT 와 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE 나 DELETE 등의 쿼리에서는 걸리지 않는다.
AUTO_INCREMENT 락은 테이블에 단 하나만 존재하기 때문에 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리는 AUTO_INCREMENT 락을 기다려야 한다.
```
---
## MySQL의 격리 수준
> 트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.
```
DIRTY READ 가 발생하는 READ UNCOMMITTED 는 일반적인 데이터베이스에서 사용하지 않고
SERIALIZABLE 또한 동시성이 중요한 데이터베이스에서 거의 사용되지 않는다.
```
### READ UNCOMMITTED
![image](https://user-images.githubusercontent.com/70372188/216781350-a1198ef6-0f71-4aad-8597-dd6e7951f109.png)
```
트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.
이처럼 어떤 트랜잭선에서 처리한 작업이 완료되지 않았는데 다른 트랜잭션에서 볼 수 있는 현상을 더티 리드라고 한다. 정합성에 문제가 많은 격리 수준이다.
```
### READ COMMITTED
![image](https://user-images.githubusercontent.com/70372188/216781441-239730fb-60f6-45f6-b1bf-9c82022d9ebf.png)

```
NON-REPEATABLE READ 발생:
트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋난다.

하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되는 경우
예시 -> 다른 트랜잭션에서 입금과 출금 처리가 계속 진행될 때 다른 트랜잭션애서 총합을 계산하는 SELECT 쿼리는 실행될 때마다 다른 결과를 가져온다.
```
![image](https://user-images.githubusercontent.com/70372188/216781499-34d666f2-6dae-4bd5-a21a-5d29614760fe.png)

### REPEATABLE READ
```
REPEATABLE READ 는 MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다.

InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK 될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드값을 변경한다.
이러한 변경 방식을 MVCC 라고 한다.

REPEATABLE READ 는 이 MVCC 를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션에서 동일한 결과를 보여줄 수 있게 보장된다.
사실 READ COMMITTED 도 MVCC 를 이용해 COMMIT 되기 전 데이터를 보여준다. 둘의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데
몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.
```
![image](https://user-images.githubusercontent.com/70372188/216781801-bcdd68e9-b9af-4e99-8b14-2e9bc9029dc3.png)
```
모든 InnoDB 의 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는)를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨
트랜잭션 번호가 포함돼 있다. 

사용자가 트랜잭션을 시작하고 장시간 트랜잭션을 종료하지 않으면 언두에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.


# https://dololak.tistory.com/446
SELECT ~ FOR UPDATE란? 
SELECT ~ FOR UPDATE 구문은 "데이터 수정하려고 SELECT 하는 중이야~ 다른 사람들은 데이터에 손 대지 마!" 라고 할 수 있습니다. 
좀 더 딱딱한 표현으로는 동시성 제어를 위하여 특정 데이터(ROW)에 대해 베타적 LOCK을 거는 기능입니다. 
이 쿼리는 언두 레코드는 잠금을 걸 수 없어서 현재 레코드의 값을 가져오게 된다 -> PHANTOM READ 발생 
```

### SERIALIZABLE
```
InnoDB 테이블에서 기본적으로 순수한 SELECT 작업은 아무런 레코드 잠금도 설정하지 않고 실행된다.
"Non-locking consistent read(잠금이 필요 없는 일관된 읽기)"라는 말이 이를 의미한다.

하지만 트랜잭션의 격리 수준이 SERIALIZABLE 라면 읽기 작업도 공유 잠금을 획득해야 한다.
즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것이다.
```

이미지 REF: https://velog.io/@jsj3282/11.-MySQL%EC%9D%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80
