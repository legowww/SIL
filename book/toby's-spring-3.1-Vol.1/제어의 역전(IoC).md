```
제어의 역전이라는 건, 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다.

일반적으로 프로그램의 흐름은 main() 메서드와 같이 프로그램이 시작되는 지점에서
다음에 사용할 오브젝트를 결정하고,결정한 오브젝트를 생성하고, 
만들어진 오브젝트에 있는 메서드를 호출하고, 그 오브젝트 메서드 안에서 다음에 사용할 것을 결정하고 호출하는 식의 작업이 반복된다.

이런 프로그램 구조에서 각 오브젝트는 프로그램 흐름을 결정하거나 사용할 오브젝트를 구성하는 작업에 능동적으로 참여한다. 
모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 
사용하는 쪽에서 제어하는 구조다.

제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 
제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 
또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다.
모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다. 
```
```
자바 프로그램은 main() 메서드에서 시작해서 개발자가 미리 정한 순서를 따라 오브젝트가 생성되고 실행된다. 그런데 서블렛을 개발하여 서버에 배포할 수는 있지만,
그 실행을 개발자가 직접 제어할 수 있는 방법은 없다. 서블릿 안에 main() 메서드가 있어서 직접 실행시킬 수 있는 것도 아니다. 
대신 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메서드를 호출한다. 서블릿처럼 컨테이너 안에서 동작하는 구조는
제어의 역전 개념이 적용되어 있다고 볼 수 있다.

템플릿 메서드 패턴의 경우에서도 제어의 역전 개념이 적용된다. 추상 UserDao를 상속한 서브클래스는 getConnection()을 구현한다. 하지만 이 메서드가 언제 어떻게 사용될지 
자신은 모른다. 서브클래스에서 결정되는 것이 아니다. 단지 이런 방식으로 기능만 구현해놓으면, 슈퍼클래스인 UserDao의 템플릿 메서드인 add(), get() 등에서 필요할 때
호출되어 사용되도록 한다는, 제어의 역전 개념을 발견 할 수 있다.

우리가 만든 UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다. 원래 ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao에게 있었다.
그런데 지금은 DaoFactory에게 있다. UserDao자신도 팩토리에 의해 수동적으로 만들어지고 자신이 사용할 ConnectionMaker의 구현체 오브젝트도 DaoFactory가 공급해주는 것을 
수동적으로 사용해야 할 입장이 됐다. 제어의 역전이 일어난 상황이다.
```
```
라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.
반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가
만든 애플리케이션 코드를 사용하도록 만드는 방식이다. 애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다.
```
