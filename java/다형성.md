# 다형성: 형(type)을 여러가지로 표현할 수 있다.
> Type(TwitterJoin)을 TwitterJoin 외에도 여러가지(Join, Withdrawl) 타입으로 표현할 수 있다.

```java
interface Join {
    void join();
}

class GoogleJoin implements join {
    void google() {}
    @Override void login() {}
}

interface Withdrawl {
    void withdrawl();
}

class TwitterJoin implements join, Withdrawl {
    void twitter() {}
    @Override void join() {}
    @Override void withdrawl() {}
}
```
```java
Join join = new Join();
Join join = new GoogleJoin();

Join join = new TwitterJoin();
join.join();
Withdrawl withdrawl = new TwitterJoin();
withdrawl.withdrawl();
```

다형성을 사용하면 구체클래스(TwitterJoin)가 아닌 추상클래스(Join, Withdrawl)로 형을 표현할 수 있다. 
그렇다면 추상클래스로 표현하는 것의 장점이 무엇일까?

## 1. 한정된 인터페이스 사용 강제
```
같은 `new TwitterJoin()` 객체를 사용하더라도, 인스턴스가 사용할 수 있는 인터페이스가 달라진다.
- Join 인터페이스가 가진 join() 메서드만을 사용하게 강제할 수 있다. join 인스턴스는 twitter(), withdrawl() 메서드를 실행할 수 없다.
- Withdrawl 인터페이스가 가진 withdrawl() 메서드만을 사용하게 강제할 수 있다. withdrawl 인스턴스는 twitter(), join() 메서드를 실행할 수 없다.

다형성을 사용하며 객체간의 협력 관계에서 드러내고 싶지않은 인터페이스들은 캡슐화(정보 은닉)되어 드러나지 않는다. 
캡슐화 덕분에 안전하게 객체간의 협력 관계를 설계할 수 있다.
```
## 2. 동일한 메세지를 수신받고 다르게 반응할 수 있다.
```java
Join joinGoogle = new GoogleJoin();
Join joinTwitter = new TwitterJoin();
joinGoogle.join();
joinTwitter.join();
```
join() 메세지를 수신받은 두 인스턴스는 서로 다르게 반응(메서드)한다.

---
`LSP`: 상속을 공통된 기능의 재사용이 아닌 추상과 구체화 관계를 사용하면 자연스럽게 지켜진다. 
`ISP`: Join 과 Withdrawl 로 인터페이스로 나누어진 형태 
