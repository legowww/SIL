# 다형성: 형(type)을 여러가지로 표현할 수 있다.
> Type(TwitterJoin)을 여러가지(Join, Withdrawl)로 표현할 수 있다.

```java
interface Join {
    void join();
}

class GoogleJoin implements join {
    void google() {}
    @Override void login() {}
}

interface Withdrawl {
    void withdrawl();
}

class TwitterJoin implements join, Withdrawl {
    void twitter() {}
    @Override void join() {}
    @Override void withdrawl() {}
}
```
```java
Join join = new Join();
Join join = new GoogleJoin();

Join join = new TwitterJoin();
join.join();
Withdrawl withdrawl = new TwitterJoin();
withdrawl.withdrawl();
```

다형성을 사용하면 구체클래스(TwitterJoin)가 아닌 추상클래스(Join, Withdrawl)로 형을 표현할 수 있다.
그렇다면 추상클래스로 표현하는 것의 장점이 무엇일까?

같은 TwitterJoin 객체를 사용하더라도, 어떤 인터페이스를 사용하느냐에 따라서 필터링되는 API가 다르다.
- Join 인터페이스가 가진 join() API만을 사용하게 강제할 수 있다. join 인스턴스는 twitter(), withdrawl() 메서드를 실행할 수 없다.
- Withdrawl 인터페이스가 가진 withdrawl() API만을 사용하게 강제할 수 있다. withdrawl 인스턴스는 twitter(), join() 메서드를 실행할 수 없다.

다형성을 사용하며 객체간의 협력 관계에서 드러내고 싶지 기능들은 캡슐화(정보 은닉)되어 드러내지 않는다.
캡슐호 덕분에 안전하게 객체간의 협력 관계를 이용할 수 있게된다.

`LSP`: 상속을 공통된 기능의 재사용이 아닌 추상과 구체화 관계를 사용하면 자연스럽게 지켜진다. 
`ISP`: Join 과 Withdrawl 로 인터페이슥 나누어진 형태 
