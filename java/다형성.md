# 다형성: 형(type)을 여러가지로 표현할 수 있다.
> Type(NaverLogin)을 여러가지(Login, Portal)로 표현할 수 있다.

```java
interface Login {
    void login();
}

class KakaoLogin implements Login {
    void kakao() {}
    @Override void login() {}
}

interface Portal {
    void portal();
}

class NaverLogin implements Login, Portal {
    void naver() {}
    @Override void login() {}
    @Override void portal() {}
}
```
```java
Login login = new Login();
Login login = new KakaoLogin();
Login login = new NaverLogin();
login.login();

Portal potal = new NaverLogin();
potal.portal();
```

다형성을 사용하면 구체클래스(NaverLogin)가 아닌 추상클래스(Login, Portal)로 형을 표현할 수 있다.
그렇다면 추상클래스로 표현하는 것의 장점이 무엇일까?

같은 NaverLogin 객체를 사용하더라도, 어떤 인터페이스를 사용하느냐에 따라서 필터링되는 API가 다르다.
- Login 인터페이스가 가진 login() API만을 사용하게 강제할 수 있다. login 인스턴스는 naver(), portal() 메서드를 실행할 수 없다.
- Portal 인터페이스가 가진 portal() API만을 사용하게 강제할 수 있다. potal 인스턴스는 naver(), login() 메서드를 실행할 수 없다.

다형성을 사용하며 객체간의 협력 관계에서 드러내고 싶지 기능들은 캡슐화(정보 은닉으 관점)되어 드러내지 않는다.
캡슐호 덕분에 안전하게 객체간의 협력 관계를 이용할 수 있게된다.

`LSP`: 공통된 기능의 재사용이 아닌 추상과 구체화 관계를 사용하면 자연스럽게 지켜진다. 
`ISP`: Login 과 Portal 로 나누어진 형태 
